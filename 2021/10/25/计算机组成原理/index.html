

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="code-O81KxcQEvT" />
  <link rel="apple-touch-icon" sizes="76x76" href="/gallery/paw_img.jpg">
  <link rel="icon" href="/gallery/paw_img.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="PPLong">
  <meta name="keywords" content="">
  <!--添加百度站点统计-->
  <meta name="baidu-site-verification" content="code-O8Xoj3awJS" />
  <!-- 谷歌网址前缀站点统计 http://www.pplong.top -->
  <meta name="google-site-verification" content="Mp6W6JCXOdt66_GIaboJrilKmC9VI0DOWE4W2d1PMRQ" />
  <meta name="description" content="计算机组成原理 运算方法与运算器 基本运算 位运算 &amp; | ~ ^：可直接采用逻辑门实现，运算延迟为一级门电路延迟 逻辑运算 &amp;&amp; || ! ： 非数值运算，操作数只能是0或者1 --&gt; 逻辑运算翻译成汇编语言时不会对应具体的运算指令，而是变成相应的程序分支结构(cmp \ je) 移位运算 &lt;&lt; &gt;&gt; : 2x 4x x&#x2F;16等都会转换成相应">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="https://www.pplong.top/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="PPLong的博客">
<meta property="og:description" content="计算机组成原理 运算方法与运算器 基本运算 位运算 &amp; | ~ ^：可直接采用逻辑门实现，运算延迟为一级门电路延迟 逻辑运算 &amp;&amp; || ! ： 非数值运算，操作数只能是0或者1 --&gt; 逻辑运算翻译成汇编语言时不会对应具体的运算指令，而是变成相应的程序分支结构(cmp \ je) 移位运算 &lt;&lt; &gt;&gt; : 2x 4x x&#x2F;16等都会转换成相应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20220405102442407.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025135856404.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025142032069.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025141255448.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025140622036.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025140828023.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025142135047.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025143233972.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025143922168.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025144253229.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025144819745.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211027093000063.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211026212402274.png">
<meta property="og:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211026212600405.png">
<meta property="article:published_time" content="2021-10-25T01:12:36.000Z">
<meta property="article:modified_time" content="2022-04-07T01:45:18.000Z">
<meta property="article:author" content="PPLong">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="计算机原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20220405102442407.png">
  
    <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script> <script>LA.init({id: "Jf1FrphVHSZkysQl",ck: "Jf1FrphVHSZkysQl"})</script>
  
  <title>计算机组成原理 - PPLong的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      
        
          
          
          
        
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css" />
      
      
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/indexing-hover.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_3317616_gaxkom6hjqm.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.pplong.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"9MuBWVsFJbGBbwW0dLf4PCir-MdYXbMMI","app_key":"ufhGMao9OY41YN3la9fN7NI0","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 90vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PPLong的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友達
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-link-fill"></i>
                娱乐
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/movie/">
                    <i class="iconfont icon-movie"></i>
                    第二人生
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/shuoshuo/">
                    <i class="iconfont icon-comment"></i>
                    唠唠
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/develop/">
                    <i class="iconfont icon-codepen-fill"></i>
                    尝鲜
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/gallery/covers/wallhaven-x8dpml.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机组成原理">
              
            </span>

            
              <div class="mt-3">
    
            
                <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-25 09:12" pubdate>
        始于: 2021年10月25日上午9点12分
      </time>
    </span>
                
</div>

<!-- 自定义的更新时间 -->
<div class="mt-1">
    
        <span class="post-meta">
  <i class="iconfont icon-clipcheck" aria-hidden="true"></i>
  <time datetime="2022-04-07 09:45" pubdate>
    更新: 2022年4月7日上午9点45分
  </time>
</span>
        
</div>

<div class="mt-1">
    
        <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
        

            
                <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54 分钟
    </span>
                

                    
                        
                            
                                <!-- LeanCloud 统计文章PV -->
                                <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span>
                                 次
                                    </span>
                                    
                                                
</div>
            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

    <div class="container-fluid nopadding-x">
        <div class="row nomargin-x">
            <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-x-md">
                <div class="container nopadding-x-md" id="board-ctn">
                    <div class="py-5" id="board">
                        <article class="post-content mx-auto">
                            <!-- SEO header -->
                            <h1 style="display: none">
                                计算机组成原理
                            </h1>
                            
                                    <div class="markdown-body">
                                        <h1>计算机组成原理</h1>
<h2 id="运算方法与运算器">运算方法与运算器</h2>
<h3 id="基本运算">基本运算</h3>
<p><strong>位运算</strong></p>
<p>&amp; | ~ ^：可直接采用逻辑门实现，运算延迟为一级门电路延迟</p>
<p><strong>逻辑运算</strong></p>
<p>&amp;&amp; || ! ： 非数值运算，操作数只能是0或者1 --&gt; 逻辑运算翻译成汇编语言时不会对应具体的运算指令，而是变成相应的程序分支结构(cmp \ je)</p>
<p><strong>移位运算</strong></p>
<p>&lt;&lt; &gt;&gt; : 2x 4x x/16等都会转换成相应的移位运算 而非乘除法运算</p>
<ul>
<li>对固定位数的移位运算，不需要逻辑器件，只需要对原有数据进行重排即可</li>
<li>对可变参数的移位运算，可将可变移位运算按权值分解成k（位移数）个固定个数的移位运算 ----&gt; <strong>桶型移位器</strong>
<ul>
<li>纯组合逻辑电路，用k个二路选择器串联构成。k个二进制位分别连接到k个二路选择器的选择控制端</li>
<li>需要k个二路选择器的时间延迟，一个二路选择器需要2级基本门电路延迟</li>
</ul>
</li>
</ul>
<p><em>移位操作的原理</em></p>
<p><strong>算术运算</strong></p>
<p>±*/：</p>
<p>C语言中的变量 x 常量以及变量 / 常量通常会被编译器优化，常量乘法会被更快的移位指令和算数加减运算指令替代。除法被常量乘法和移位指令的组合替代</p>
<h3 id="定点加减法运算">定点加减法运算</h3>
<p>参考CSAPP，华科书中也有习题</p>
<h4 id="溢出检测">溢出检测</h4>
<h4 id="逻辑实现">逻辑实现</h4>
<h5 id="全加器">全加器</h5>
<p>3个输入： 要加的两个位数 X Y、是否有来自低位的进位 C_{i}<br>
2个输出： 是否有高位的进位C_{i}、相加的结果S_{i}</p>
<p>$$S_{i}=  X_{i} \bigoplus Y_{i} \bigoplus C_{i}$$</p>
<p>高位进位输出的两种表达方式：</p>
<p>$$C_{i}=  X_{i}Y_{i} + (X_{i} + Y_{i})C_{i}$$</p>
<p>$$C_{i}=  X_{i}Y_{i} + (X_{i} \bigoplus Y_{i})C_{i} $$</p>
<p>开销不同：</p>
<ul>
<li>①式：3个两输入与门、1个三输入或门、2个两输入异或门</li>
<li>②式：2个两输入与门、1个两输入或门、2个两输入异或门，成本低，延迟高</li>
</ul>
<p>注意这里主要是$$C_{i+1}$$的运算区别</p>
<p><strong>半加器</strong></p>
<p>没有进位输入、内部逻辑只有一个异或门来产生合数，一个与门产生进位输出</p>
<p>$$S_i = X_i \bigoplus Y_i$$     $$C_{i+1} = X_iY_i$$</p>
<p>半加器通常用于没有进位输入的情况，以减少不必要的硬件开销，时间延迟为3T</p>
<h5 id="多行串行加法器">多行串行加法器</h5>
<p>n个全加器的进位链串联得到n位串行加法器 ----&gt; 行波进位加法器</p>
<p>高位的全加器必须等待低位进位后才能开始运算。但S和C的运算<s>是并行的</s>，<s>互不等待</s>的有符号、无符号运算均可</p>
<ul>
<li>无符号的加法：溢出检测信号 $$C_n$$</li>
<li>有符号 溢出检测：overflow,最高数值位进位和符号位进位异或得到</li>
</ul>
<h5 id="可控加减法电路">可控加减法电路</h5>
<p>$$[X]_补 - [Y]_补 = [X-Y]_补 = [X]_补 + [-Y]_补$$</p>
<p>Y的所有位与Sub信号进行异或后送入 Sub = 1时，则送入的是Y的反码，并且Sub也实现了末尾+1的取反操作</p>
<h5 id="先行进位加法器-CLA">先行进位加法器(CLA)</h5>
<p>n位串行加法电路高位的运算以来与低位进位输入，全加器并不能并行运行，位宽较大时性能差</p>
<p>替换： $$G_i = X_iY_i$$     $$P_i= X_i \bigoplus Y_i$$<br>
Gi = 1时，Ci+1一定为1 ---- Gi：进位生成函数<br>
Pi = 1，Ci才能传递到进位输出Ci+1—Pi：进位传递函数<br>
最终有：</p>
<p>$$G_n = G_{n-1} + P_{n-1}G_{n-2} + … + P_{n-1}P_{n-2}…P_2P_1P_0C_0$$</p>
<p>根据公式利用欧冠额外的组合逻辑电路<strong>提前</strong>产生各位运算加法所需要的所有进位输入，再利用$$S_i = P_i \bigoplus C_i$$进行一级异或门运算可得到最终的和数，n越大，时间延迟也大，通常按照4位一组进行先行进位（先行进位电路位数越多、扇入系数越大、制造难度越大）</p>
<p><strong>并行加法器</strong></p>
<p>4位先行进位电路 + 生成GP的与门异或门电路 + 4个异或门 = 4位快速加法器（并行加法器）</p>
<div class="note note-primary">
            <p><em>如何构建更大位宽的加法器电路？</em></p><p>多个快速加法器的进位链串联（但组间仍然是串行计算）。可以考虑将4个4位快速加法器输出的成组进位生成、传递函数和C0连接到先行进位电路的输入端，产生4个进位信号，再对对应信号连接到相应的快速加法器的进位输入端即可构成16位组内并行进位、组间并行进位的快速加法器</p>
          </div>
<h4 id="补码加减法">补码加减法</h4>
<div class="note note-info">
            <p>主要理解从原码到补码的优化过程</p>
          </div>
<p>一种补码诞生的思路，设 a(known) + b(unknown) = 0，根据进位规则来求b，最终诞生了补码</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20220405102442407.png" srcset="/img/loading.gif" lazyload alt="image-20220405102442407"></p>
<p><strong>补码加减法的好处</strong></p>
<p>能够让计算机通过加法也能运算出有正负数和进位时的正确结果，方便计算。而不用通过原码运算后再复杂的判断大小。并且也可以只用加法器实现加减法</p>
<p>知识：</p>
<ul>
<li>~a = -a -1;</li>
<li>当我通过加法计算出一个负数的补码时，我如何确定它的原码的表示数值。按照补码的规则倒推，先减1再取反</li>
</ul>
<p>所有就有对signed int = (1 &gt;&gt; 31) - 1，其数值等于 -(1&gt;&gt;31)，其实理解应该从位的方式先理解，然后再转化到具体的表示形式有不同的取值，如果是unsigned int则为原值</p>
<h3 id="定点乘法运算">定点乘法运算</h3>
<ul>
<li>多位加法器循环累加，硬件开销小但需要时序电路控制，需要多个时钟周期才能得到运算结果</li>
<li>加法器阵列构成的纯组合逻辑电路，硬件开销大但只需要一个时钟周期</li>
</ul>
<h4 id="原码乘法">原码乘法</h4>
<p>基本累加核心公式： $$P_{i+1} = (P_i + y_{n-1}|x|)2^{-1}$$</p>
<p>两个n位数参加乘法运算需要 n次加法和n次移位操作，需要长度2n的积寄存器，<strong>符号位单独参加运算</strong></p>
<ul>
<li>需要多输入全加器 —&gt; 基于FA的循环累加0或被乘数</li>
<li>不同位部分左移次数不同 —&gt; 右移部分积  乘数寄存器</li>
<li>需要长度为2n的积寄存器 —&gt; 从部分积和乘数寄存器取结果</li>
</ul>
<p>**同步逻辑右移：**P y拼接在一起进行逻辑右移</p>
<p>核心是理解为什么会将y和P放在一起，进行同步逻辑右移：公式+便捷</p>
<h4 id="补码乘法">补码乘法</h4>
<p>$$[x*y]_补 = [x]_补 * (0.Y_1Y_2Y_3…Y_n) - Y_0 * [X]_补$$</p>
<p>展开后可得： $$[X * Y]<em>补 = [X]<em>补 * \sum</em>{i=0}^n (y</em>{i+1} - y_{i})2^{-i}$$</p>
<ul>
<li>i=n时，y_n+1 = 0</li>
<li>yn+1是哪个寄存器？ 在乘数寄存器Y后增加一位，为了乘法按照规则进行</li>
<li>算数右移的对象有哪些？   部分积和乘数寄存器</li>
</ul>
<p><strong>符号位参加运算</strong></p>
<ol>
<li>
<p><strong>Booth算法</strong></p>
</li>
<li>
<p><strong>补码一位乘法算法</strong></p>
<p>逻辑左移、逻辑右移</p>
</li>
</ol>
<h4 id="乘法运算器设计">乘法运算器设计</h4>
<p><strong>原码一位乘法</strong></p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025135856404.png" srcset="/img/loading.gif" lazyload alt="image-20211025135856404"></p>
<p><strong>补码一位乘法</strong></p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025142032069.png" srcset="/img/loading.gif" lazyload alt="image-20211025142032069"></p>
<ul>
<li>需要时序控制(A-&gt; ALU…)</li>
<li>需要多次循环累加</li>
</ul>
<p><strong>阵列乘法器</strong></p>
<p>与门阵列+FA阵列</p>
<p><strong>原码阵列乘法器</strong></p>
<p>原理：</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025141255448.png" srcset="/img/loading.gif" lazyload alt="image-20211025141255448"></p>
<p>具体实现： （手工乘法）</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025140622036.png" srcset="/img/loading.gif" lazyload alt="image-20211025140622036"></p>
<p>每一行都是串行进位加法器  ，改进后（打破串行进位链）</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025140828023.png" srcset="/img/loading.gif" lazyload alt="image-20211025140828023"></p>
<p>速度更快，同级的FA不存在串行进位了，但需要 增加一行，处理最后一行FA的进位关系</p>
<p><strong>补码阵列乘法器设计</strong></p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025142135047.png" srcset="/img/loading.gif" lazyload alt="image-20211025142135047"></p>
<p>算前求补和算后求补</p>
<h3 id="定点数除法">定点数除法</h3>
<p>手工除法怎么算 ----&gt; 启示：除法运算可通过减法实现</p>
<p>存在问题：</p>
<ul>
<li>除数右移次数可能很多</li>
<li>需要长度为2n的寄存器保存余数</li>
<li>如何判断每步是否<strong>够减</strong>
<ul>
<li>余数为正时，商1，将余数左移1位，再与除数做比较</li>
<li>余数为负，不够减，商0。加除数来恢复成原来的值，将余数左移一位并做比较</li>
</ul>
</li>
</ul>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025143233972.png" srcset="/img/loading.gif" lazyload alt="image-20211025143233972"></p>
<p>注意：最终算出来的余数是经过左移改变的，所以需要进行相应位数右移来还原</p>
<p>缺点：运算步数不能在运算之前就确定（来源：恢复余数的次数无法确定）</p>
<p><strong>加减交替法（不恢复余数法）</strong></p>
<p>余数&lt; 0 时不需要恢复，仍然左移，只是再加上Y,结果是和恢复余数是一样的</p>
<p>过程简单、运算步数固定(???)</p>
<p><strong>电路图</strong></p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025143922168.png" srcset="/img/loading.gif" lazyload alt="image-20211025143922168"></p>
<h4 id="阵列除法">阵列除法</h4>
<p><strong>可控制加/减单元 CAS</strong></p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025144253229.png" srcset="/img/loading.gif" lazyload alt="image-20211025144253229"></p>
<p>逻辑功能：</p>
<p>$$ S_i = A_i \bigoplus (B_i \bigoplus P) \bigoplus C_i$$</p>
<p>$$ C_{i+1} = (A_i + C_i) (B_i \bigoplus P) + A_i C_i$$</p>
<p>P=0时实现加法功能，P=1时实现减法功能</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211025144819745.png" srcset="/img/loading.gif" lazyload alt="image-20211025144819745"></p>
<ul>
<li>第一步一定是减法 P=1，后面则取决于每一步的商</li>
<li>最左边的CAS的进位输出是商，且本位商决定下一步是加操作还是减操作</li>
<li>每执行完一步除法，除数就右移一位（手工除法）（CAS电路都向右偏移一列，间接实现了余数的左移）</li>
</ul>
<h3 id="浮点运算">浮点运算</h3>
<p>规格化浮点数，将数据的表示范围和精确度统一</p>
<p>规格化的浮点数补码形式 尾数形式为：<br>
00.1xxxx、11.0xxxxx(最高有效数据位与符号位不能相同)</p>
<ul>
<li>结果为00.0xxxxx或者11.1xxxx,需要<strong>左规格化</strong>，将尾数向左移动，每移动一次，阶码-1，知道满足要求</li>
<li>尾数结果为01.xxxx或者10.xxxxx，表明尾数求和结果&gt;1，仅需执行<strong>一次右移</strong>，阶码+1即可</li>
</ul>
<p>$$x = 2^{Ex}* Mx$$             $$ y = 2^{Ey} * My$$<br>
$$x + y = (2^{Ex - Ey} * Mx + My )* 2^{Ey}$$</p>
<p>步骤：</p>
<ol>
<li>对阶
<ol>
<li>求阶差Ex + (- Ey)</li>
<li>右移阶码小的浮点数的尾数并同步增加其阶码，直到两数阶码相等</li>
</ol>
</li>
<li>尾数加减</li>
<li>结果规格化</li>
<li>舍入：右移规格话的同时可能丢失一些低位的数值位，为提高精度，可采用
<ol>
<li>0舍1入：若右移出的最高位是1，则在最低位加1</li>
<li>恒置1：只要数字位1被移走，就将最后1位恒置1</li>
</ol>
</li>
<li>溢出处理：
<ol>
<li>阶码上溢：阶码的符号位为01</li>
<li>阶码下溢：阶码的符号位为10</li>
</ol>
</li>
</ol>
<p>浮点乘法和除法都大同小异</p>
<h2 id="存储器系统">存储器系统</h2>
<h3 id="存储器概述">存储器概述</h3>
<p>**存储单元：**存储器中的最小存储单位 – 存储元</p>
<p>**MOS：**场效应管。金属+氧化物+半导体场效应晶体管</p>
<h4 id="分类-v3">分类</h4>
<p><strong>按照存储介质分类</strong></p>
<ul>
<li>
<p>磁存储器：磁性材料做介质，利用磁化单元剩磁的不同磁化方向来存储数据0 和 1.体积大、存储速度慢、单位容量成本低</p>
</li>
<li>
<p>半导体存储器：</p>
<ul>
<li>
<p>双极型存储器： TTL、ECL</p>
</li>
<li>
<p>金属氧化物半导体存储器：MOS存储器</p>
<ul>
<li>静态MOS存储器 SRAM</li>
<li>动态MOS存储器 DRAM</li>
</ul>
<p>存储体积小，存储速度快，单位容量成本高</p>
</li>
</ul>
</li>
<li>
<p>光存储器： 利用介质的光学特性（CD-ROM DVD-ROM）以刻痕形式将数据存在盘面，用激光束照射盘面，靠不同的反射率来读信息</p>
<ul>
<li>磁光盘：激光+热辅助磁化的方式，根据反射光的偏振方向不同读信息</li>
</ul>
</li>
</ul>
<p><strong>按照存取方式分类</strong></p>
<ul>
<li>随机存储器：RAM，按照地址随机读写数据存储单元，存取访问时间与存储单元的位置无关。现在大量的半导体存储器都是RAM</li>
<li>顺序存储器：SAM，存储单元的内容只能依地址顺序访问，<strong>访问速度与存储单元的位置有关</strong>的存储器（磁带存储）</li>
<li>直接存储器： DAM，不必经过顺序搜索就能在存储器中直接存取信息，具有RAM和SAM的特性（磁盘存储器）。由于磁盘存在机械寻道和旋转延迟，因此数据访问时间和磁头与目标扇区的距离有关</li>
</ul>
<p><strong>按照信息的可改写性</strong></p>
<ul>
<li>读写存储器：既能读出又能写入信息</li>
<li>只读存储器：ROM</li>
</ul>
<p><strong>按照功能和存取速度分类</strong></p>
<ul>
<li>寄存器存储器（CPU类）</li>
<li>高速缓冲存储器： 在寄存器和驻村之间的高速小容量存储器，存放CPU即将或者经常要使用的指令和数据。采用静态RAM构成</li>
<li>主存储器：CPU中除了寄存器之外唯一能直接访问的存储器，存放执行和数据。CPU通过主存地址直接、随机地读写存储器。主存一般由半导体构成，可能还包括硬件端口和BIOS</li>
<li>外存储器： 容量大、速度低。存放当前暂时不参与运行的程序与数据</li>
</ul>
<p>存储器带宽： 单位时间内存储器能传输的信息量 （位/秒 字节/秒）</p>
<h4 id="存储系统层次结构">存储系统层次结构</h4>
<h4 id="主存的基本结构">主存的基本结构</h4>
<p>主存是机器指令直接操作的存储器，采用主存地址进行随机访问</p>
<ul>
<li>地址译码器接收到来自CPU的n位地址信号，经过译码、驱动后产生2^n根地址译码信号，每一根地址译码信号连接一个存储单元</li>
<li>数据寄存器永远是存取将要送走或者送来的数据</li>
<li>读写控制相当于一个网关，产生读写的信号</li>
</ul>
<h4 id="主存中的数据存放">主存中的数据存放</h4>
<p><strong>存储字长：</strong> 主存的一个存储单元所存储的二进制位数<br>
<strong>数据字长（字长）：</strong> 计算机一次能处理的二进制数的位数<br>
<strong>存储字长和数据字长可以不同</strong></p>
<p>(网上说数据字长是计算机数据存储所占用的位数，机器字长是CPU一次能处理数据的位数)</p>
<p><strong>地址访问模式</strong></p>
<p>主存按照字节进行编址，可以通过字节地址、半字地址、字地址（字节地址的逻辑右移）来进行访问</p>
<p><strong>大端小端</strong></p>
<p>不同的访问顺序导致访问的数据完全不同</p>
<ul>
<li>小端： 存储器的低字节地址单元存放的数据的低字节
<ul>
<li>主流处理器采用</li>
</ul>
</li>
<li>大端： 存储器的低字节地址单元存放的数据的高字节</li>
</ul>
<p><strong>数据的边界对齐</strong></p>
<p>一个多字节变量分布在不同的字存储单元中，访问改变量就需要多个存储周期</p>
<ul>
<li>dw数据起始地址的最末3位为000，地址是8的整数倍</li>
<li>w数据起始地址最末两位为00.地址是4的整数倍</li>
<li>半字树其实地址的最低一位是0，地址是2的整数倍</li>
<li>单字节数据不存在边界对齐问题</li>
</ul>
<p>以空间换时间，<a target="_blank" rel="noopener" href="https://blog.csdn.net/lgouc/article/details/8235471">理解为什么需要内存对齐</a></p>
<h3 id="半导体存储器">半导体存储器</h3>
<p>存取速度快，体积小，性能好  分为RAM和ROM存储器</p>
<p>作为存储单元电路，需要具备：</p>
<ul>
<li>具有两种稳定状态</li>
<li>状态经外部信号控制可相互转换</li>
<li>经控制后能读出其中的信息</li>
<li>信息能长期保存</li>
</ul>
<p><strong>6管MOS存储单元</strong></p>
<p><strong>存储单元扩展</strong></p>
<h4 id="静态MOS存储器">静态MOS存储器</h4>
<p>一维行扩展： 单译码结构<br>
二维行列扩展： 双译码结构，两个方向设置n/2路输入译码器。输出信号少很多（为啥？），译码电路成本降低</p>
<p>译码器（最小项发生器）：组合逻辑电路，将n位二进制信号输入翻译成2^n个输出信号，每个输出信号都是n位输入的最小项</p>
<p><strong>结构</strong></p>
<h4 id="动态MOS存储器">动态MOS存储器</h4>
<p>SRAM存储密度低，即使存储单元不写入，也会有电流，功耗大</p>
<ol>
<li>
<p><strong>单管DMOS存储单</strong></p>
<p>一个MOS管+ 一个电容</p>
<p>缺陷：</p>
<ol>
<li>DRAM利用存储电容的电荷表示数据，重发点过程慢，导致了读写速度比SRAM单元慢</li>
<li>存储电容的容量比寄生电容小一个容量级，二者进行电荷重分配产生的电流十分微弱，需要灵敏的差分放大器检测。读操作可能导致电荷减少，破坏原有数据，为避免数据丢失，读出后会将数据重新写入—数据恢复</li>
<li>数据恢复以及读出信号放大的逻辑由再生放大电路实现，每组列线上共享</li>
<li>电容的电荷会逐渐泄露，数据只能保存较短时间。需要类似读操作的方式对存储单元补充电荷—刷新----为什么叫DRAM</li>
</ol>
</li>
<li>
<p><strong>如何刷新</strong></p>
<p>最大刷新周期： 信息存储到数据丢失之前的时间间隔<br>
刷新周期：存储器实际完成两次刷新的间隔（2ms 4ms 8ms/…）</p>
<p>动态存储器按行进行刷新，为减少刷新周期，可减少存储矩阵的行数、增加列数，只需要给出行地址即可</p>
<p>刷新时DRAM不能响应CPU的访问，三种解决方式</p>
<ul>
<li>集中刷新
<ul>
<li>读写操作期间不受刷新操作的影响，存储器速度快</li>
<li>存在较长的时间死区，在集中刷新的n个读写周期内，CPU都不能访问存储器</li>
</ul>
</li>
<li>分散刷新
<ul>
<li>划分存储周期，前段时间来读写 后端时间来刷新（类似微时隙再分），则过n个ts就可以完全刷新，在一个刷新间隔内能进行多次刷新</li>
<li>不存在死区</li>
<li>刷新过于频繁，影响系统速率</li>
</ul>
</li>
<li>异步刷新
<ul>
<li>集中刷新+分散刷新</li>
<li>x行的刷新平均分散在刷新间隔内，每个一段时间刷新一行，将刷新间隔的最后0.5us来刷新</li>
<li>充分利用2ms时间，保持了系统的告诉特性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="只读存储器">只读存储器</h4>
<ul>
<li>掩膜式ROM MROM：把0 1 信息存储在掩膜图形中，芯片完成后各存储位状态被固定，不能修改。灵活性差可靠性高</li>
<li>可编程ROM PROM ：用户可写一次，采用熔丝代替开关，存储器出厂时每个存储单元的熔丝都是连接状态，存储数据全为0.可利用编程器进行一次改写，可通过辅助电路有选择地将某些存储单元的熔丝高压熔断，再写入数据1
<ul>
<li>除熔丝型，还有采用反向二极管的PROM,默认状态不导通，默认数据为1，改写时采用高压将其永久性击穿，导通数据为0.</li>
</ul>
</li>
<li>可擦除可编程ROM EPROM：可多次写入，可擦除进行重写
<ul>
<li>浮置栅：MOS管的栅极埋入SiO2中且浮空与外界绝缘。</li>
<li>利用浮置栅MOS管的导通和截止状态存储数据，初始无电荷，MOS管截止；写入时在源级和漏级加上编程电压，MOS管在高压作用下被击穿。高压撤出后，浮置栅有绝缘层保卫，电荷无法泄露，浮置栅带电,MOS管导通，信息存入</li>
<li>擦除：紫外线照射，形成光导现象，浮置栅上电荷完全泄露。所有单元回到初始状态</li>
</ul>
</li>
<li>电可擦除可编程ROM EEPROM：在浮置栅上方增加了控制栅极，写入方式与EPROM相同。
<ul>
<li>擦除时不需要紫外线照射石英玻璃，只需要将控制栅极加上高电平就可以将浮置栅的电荷泄露掉</li>
<li>可以精准地删除某一存储单元</li>
</ul>
</li>
<li>闪存 Flash Memory：快速擦写、非易失性存储器。与EEPROM结构相似。闪存的工作方式包括读工作方式、编程工作方式、擦除工作方式和功耗下降方式，编程和擦除方式采用写命令到命令寄存器的方法来进行。</li>
</ul>
<h3 id="主存的组织和与CPU的连接">主存的组织和与CPU的连接</h3>
<p>单片存储芯片的容量有限，通常需要将多篇存储芯片按照一定方式组织并与CPU连接。</p>
<h4 id="存储器的扩展">存储器的扩展</h4>
<ol>
<li>
<p><strong>位扩展</strong></p>
<p>字长扩展、数据总线扩展</p>
<p>当存储芯片的数据总线位宽 &lt; CPU数据总线位宽时采用</p>
<p>将所有存储芯片的<strong>地址线、读写控制线</strong>并联分别与<strong>CPU的地址线和读写控制线</strong>连接，存储芯片的<strong>数据线和CPU数据线</strong>连接；所有芯片的<strong>片选控制线</strong>并联后与**CPU的访存请求信号MERQ#**连接</p>
</li>
<li>
<p><strong>字扩展</strong></p>
<p>容量扩展、地址总线扩展</p>
<p>存储芯片的存储容量不能满足存储器对存储容量的要求时采用。</p>
<p>将所有<strong>存储芯片的数据线、读写控制线</strong>各自并联，分别与<strong>CPU的数据线和读写控制线</strong>连接</p>
</li>
<li>
<p><strong>字位同时扩展</strong></p>
<p>存储芯片的数据位宽和存储容量均不能满足存储器的数据位和存储总容量时采用</p>
<p>先位扩展 – 后字扩展</p>
</li>
</ol>
<h3 id="并行主存系统">并行主存系统</h3>
<p>如何通过发觉存储系统的并行性来提高存取速度</p>
<ol>
<li>
<p>双端口存储器</p>
<p>一个存储器有两组相互独立的端口，每个端口可以独立地进行读写操作</p>
<p>特点：</p>
<ol>
<li>
<p>并行读写</p>
<p>不同端口使用各自的地址线、数据线和控制线对存储器中的不同存储单元进行同时读写</p>
</li>
<li>
<p>冲突处理</p>
<p>两个端口地址相同时会发生读写冲突 ，解决 ----&gt; 每个端口设置标志 $$\overline {BUSY}$$,由判断逻辑决定哪个端口有限进行读写操作，另一个端口的标志设置为0（低电平）以延迟对存储器的访问。优先端口的操作完成后，被延迟端口的标志会复位</p>
<p>效率不能实际提高两倍 ----&gt; 冲突访问不能避免</p>
</li>
</ol>
</li>
<li>
<p>单体多字存储器</p>
<p>类似位扩展方式。多个存储模块共享地址总线，按同一地址并行访问不同存储模块的同意单元，一个存储周期内访问多个存储字。</p>
<p>常用： <strong>多通道内存技术</strong> （联动模式）：<br>
两条完全相同的64位内存共享地址总线和片选信号线， 同一时刻两根内存并发工作，各自<strong>访问同一地址单元</strong>中的64位数据（总共128位）并送入内存控制器。（要求两根内存的容量、时序、频率必须完全一致（书中有图，非常帮助理解））</p>
<p><strong>非联动模式</strong>：内存控制器通过独立的片选信号、地址总线、读写控制线连接两根内存，数据总线页是独立的两条64位总想爱你。内存可以并发工作，但<strong>二者地址、读写命令不必同步</strong>。只需要频率相同</p>
</li>
<li>
<p>多体交叉存储器</p>
<p>多个容量和存取速度相同的存储模块构成</p>
<ol>
<li>
<p>高位多体交叉（顺序编址模式）</p>
<p>目的：扩充存储器容量，与存储器字扩展完全相同。用高位地址译码产生片选信号，选择不同的存储模块；低位地址直接选择存储模块内的不同存储单元</p>
<p>特点：</p>
<ul>
<li>相邻地址在同一存储体内</li>
<li>不同存储体中的地址不相邻</li>
<li>同一存储体的地址单元是连续的，程序执行过程基本是对同意存储提访问频繁，而其他存储提基本空闲，无法实现多个存储体的并行工作</li>
</ul>
<p>eg：计算机内存插槽可扩展性</p>
</li>
<li>
<p>低位交叉方式（交叉编址模式）</p>
<p>低位地址译码进行片选，高位地址选择存储模块内的不同存储单元</p>
<p>特点：</p>
<ul>
<li>相邻的地址处在不同的存储体内</li>
<li>同一存储体中的字体不相邻</li>
<li>适合突发的顺序访问模式</li>
<li>顺序访问时，各存储模块按照流水线的方式轮流存取</li>
</ul>
<p>为提高顺序访问时个存储模块的并行性，个存储模块均具有各自独立的地址寄存器、数据寄存器和读写控制电路。</p>
</li>
</ol>
</li>
</ol>
<p>计算不同条件下读取字所需要的时间和带宽 — 书中P.121</p>
<div class="note note-success">
            <p>存储时间和存储周期的区别</p><p>存储时间：CPU读写内存内数据的过程时间（发出命令到接受数据）<br>存储周期：连续启动两次读或写操作锁需间隔的最小时间（两次存储时间+恢复时间）</p>
          </div>
<h3 id="高速缓冲存储器">高速缓冲存储器</h3>
<h4 id="cache">cache</h4>
<p>SRAM速度快但容量有限，成本高功耗大。 为进一步提升CPU访问主存的性能 — 在CPU和主存间增加隐藏的小容量快速的SRAM<br>
将主存中经常访问或者即将访问的数据副本调度到小容量的SRAM中，使得大部分数据访问都能在cache中进行（为什么？因为CPU执行的程序具有较强的程序局部性）</p>
<p><strong>程序局部性</strong></p>
<p>程序在执行时呈现局部规律性（一段时间内，程序的执行仅限于程序中的一部分，执行所需的执行和数据页局限于某个存储区域内）</p>
<ul>
<li>空间局部性：一旦程序访问了某个存储单元，其附近的存储单元页即将被访问（代码、数组、结构体、全局变量）</li>
<li>时间局部性：程序访问一个存储位置，该位置在未来可能被多次访问（循环结构）</li>
</ul>
<h5 id="概念-v10">概念</h5>
<p>与主存一样，被分为多个数据块，数据块又包含多个字。划分为块地址和块内偏移地址（主存块地址字段&gt;cache块地址字段，块内偏移是相同的）</p>
<p>CPU通过字节地址访问cache先判断数据是否在cache中，如果在，则<strong>数据命中</strong>；<br>
数据不在，<strong>数据缺失</strong>，缺失时的访问时间叫<strong>缺失补偿</strong>（包括数据查找t、主存访问t、cache访问t），相邻数据也会随着数据块一起加载到cache中</p>
<h5 id="读写流程">读写流程</h5>
<p><strong>读</strong></p>
<p>CPU需要访问主存时，先以主存地址RA中的主存块地址为关键字在查找表中查找，能查到则命中</p>
<p><strong>写</strong></p>
<p>以主存字节地址WA中的主存块地址为关键字在查找表中进行数据查找，先写到cache再写到主存<br>
<strong>脏数据</strong>：cache中数据和主存中原始数据不一致现象</p>
<ul>
<li>写回策略：不再写入到主存，响应速度最快，但产生不一致性。每个cache行要配置一个修改位（<strong>脏位</strong>）。当某行要被替换时，检测是否脏位为1，是则会写入到内存中再替换</li>
<li>写穿策略：写回到主存中，慢速</li>
</ul>
<p>数据缺失时：</p>
<ul>
<li>写分配法：将WA对应的数据块载入到cache中，在进行和写命中一致的策略。</li>
<li>另外的：数据直接写入慢速的主存中</li>
</ul>
<p><strong>关键技术</strong></p>
<ol>
<li>数据查找</li>
<li>地址映射</li>
<li>替换策略</li>
<li>写入策略</li>
</ol>
<p><strong>相联存储器CAM</strong></p>
<p>按内容进行访问的存储器，用于存放查找表 KV形式。用于cache的快速查找</p>
<p>所有存储单元的key字段同时与CAM的输入检索关键字进行并发比较。每个存储单元都对应一个独立的比较器，硬件成本高，容量一般较小</p>
<h5 id="地址映射">地址映射</h5>
<p>主存地址空间映射到cache的地址空间,三种方式：</p>
<ol>
<li>
<p>全相联：各主存块可映射到cache的任意数据块</p>
<p>(主存)一对多(cache)，新的主存块可以在啊入道cache中的任意空位置。<br>
利用率最高、查找成本高，需要CAM提供快速查找功能</p>
<p>需要记录相关标记：主存块地址标记、有效位、脏数据标志位…   —cache槽中（cache有多少个数据块就对应多少个cache槽）</p>
<p>数据查找时直接将主存块地址和所有cache行中的标记字段主存块地址进行并发比较</p>
<p>cache副本缓冲区容量 = n x 2^w字节  实际容量为 n * (1+s+8*2^w)位(s :tag, w: offset)</p>
<p>实现：</p>
<p>主存地址被划分位(tag,offset)，tag代表主存块地址。比较时tag与所有航的标记字段tag进行多路并发比较</p>
<p><strong>特点：</strong></p>
<ol>
<li>cache利用率高</li>
<li>cache冲突率低</li>
<li>查找时要并发比较查找表的所有项，硬件成本高，适合小容量cache</li>
<li>cache满载时替换算法复杂</li>
</ol>
</li>
<li>
<p>直接相联：主存块只能映射到cache中的固定块</p>
<p>每个主存地址只能映射到cache中的固定行</p>
<p>cache行号i = 主存块号 j mod (cache行数n)</p>
<p>主存地址可细分为：区地址tag、区内行索引index、块内偏移offset</p>
<p>cache实际容量n * （1 + s -r + 8 * 2^w）位（行数位r，区地址有s-r位）</p>
<p>通过index字段可快速访问对应cache行的标记与标志字段，如果<strong>标记字段有效</strong>且<strong>与主存地址中的区地址相同</strong>，就命中。查找表不需要存放在相联存储器中</p>
<p>实现：</p>
<p>主存地址被划分为 (tag index offset)</p>
<p><strong>特点：</strong></p>
<ol>
<li>cache利用率低，可能有冲突</li>
<li>cache未满也可能发生数据冲突</li>
<li>查找时只需要根据index访问对应cache行的tag比较，一个比较器即可，硬件成本低（因为不需要并发比较了），适合大容量cache使用</li>
<li>不需要使用复杂的替换算法</li>
</ol>
<p>相应例题 ： P.130(还挺多的，建议好好看一下)</p>
</li>
<li>
<p>组相联：主存快只能映射到cache固定组中的任意块</p>
<p>前两种方式的折中，既能提高命中率，又能降低硬件的开销（全相联在组内进行比较，需要K个比较器）</p>
<p>将cache分成固定大小的组，每组k行（k-路组相联）。主存数据块首先先采用直接相联映射的方式定位到固定的组，然后用全相联映射方式映射到组内的任何一个cache行。</p>
<p>cache组号 = 主存块号 mod(cache组数)</p>
<p>实现：</p>
<p>主存地址被划分位(tag 组索引index offset)</p>
<p>cache容量 = 2 n * (1+s-d+8* 2^w)位</p>
<p>数据淘汰在指定的组内选择cache行进行淘汰</p>
</li>
</ol>
<h5 id="应用-v3">应用</h5>
<p><strong>分离cache</strong></p>
<p>指令和数据不在同一个cache中统一cache：指令和数据都在cache中，，但执行部件存取数据时，指令预取部件又要从统一cache读指令，两者会发生冲突</p>
<p><strong>多级cache</strong></p>
<p>一级cache L1: cache和处理器集成在同一芯片内，减少对片外总线的访问。容量较小<br>
二级cache L2: 主存和CPU之间（L1cache容量小 8 K, L2-- 256KB~1MB）</p>
<h4 id="替换算法">替换算法</h4>
<ol>
<li>
<p>FIFO：</p>
<p>需要记录每个cache行载入cache的时间戳，开销小</p>
</li>
<li>
<p>LFU：Last Frequently Used</p>
<p>每行必须设置淘汰计数器，可能因为时序问题而淘汰使用增长率较高的cache行</p>
</li>
<li>
<p>LRU：Last Recently Used</p>
<p>每行设置计数器，每命中一行，对应的计数器清零，其他行的计数器+1.使得cache有较高的命中率</p>
<p>难点：快速比较多行计数 — 二路级联cache,一个主存快只能在特定组的两行中存放（二选一）</p>
</li>
<li>
<p>随机替换</p>
</li>
</ol>
<h3 id="虚拟存储器">虚拟存储器</h3>
<h4 id="原理-v5">原理</h4>
<p>采用cache提高了CPU对主存的访问速度问题，但不能解决主存容量不足的问题<br>
虚拟存储器处于“主存-缓存”层次，通过增加部分软件和硬件，使得赋存和主存构成一个整体，就像一个单一的主存可供CPU直接访问。程序员可用虚拟存储器提供的虚拟地址进行变成，不再受主存大小的限制。</p>
<p>利用程序的局部性，采用按需加载的方式加载代码和数据。加载程序时不直接加载入主存中，而仅在相应的虚拟地址转换表中登记虚拟地址对应的磁盘地址。程序执行病访问虚拟地址对应的程序和数据时，产生缺页异常，将真正的程序和代码载入</p>
<p><strong>地址映射</strong></p>
<p>虚拟存储器中三种空间地址</p>
<ol>
<li>虚拟地址空间：编写程序的地址空间</li>
<li>主存地址空间：物理地址空间（实地址空间）</li>
<li>辅存地址空间：磁盘存储器地址空间</li>
</ol>
<p>地址映射：将虚拟地址空间映射到主存空间，将访问的内容按照某种规则从辅存装入主存并在虚、实地址间建立联系<br>
地址转换：程序被装入主存实际运行时，把虚地址转换成实地址或者磁盘地址，让CPU从主存或磁盘中读取信息</p>
<p>在虚存系统中运行程序时，CPU以虚拟地址访问主存，使用MMU（存储管理控制部件）找出虚地址和实地址之间的关系，并判断这个虚地址对应的内容是否在主存中，如果在则通过MMU将虚拟地址转化为物理地址；如果不在，则把包含这个字的一页或一个程序段调入主存</p>
<p>根据虚拟存储器对主存逻辑结构划分的粒度，虚存可分为页式、段式、段页式虚存</p>
<h4 id="页式虚拟存储器">页式虚拟存储器</h4>
<p>以页位逻辑结构划分你信息传送单位的虚拟存储器。<br>
虚拟空间和主存空间 被划分成固定大小的页（常见4KB）</p>
<p><strong>虚拟地址划分</strong></p>
<p>虚拟地址 = 虚拟页号 VPN + 虚拟页偏移 VPO<br>
物理地址 = 物理页号 PPN + 物理页偏移 PPO<br>
(VPN &gt; PPN 取决于虚拟空间和主存空间的容量， VPO = PPO 决定页面大小)</p>
<p><strong>页表</strong></p>
<p>虚实地址的转换通过<strong>页表</strong>进行：一张保存虚拟页号VPN和物理页号PPN对应的关系的查找表，由若干个表项组成的数组。<br>
以VPN作为索引，每个表项包括有效位和物理页号，还包括修改位、使用位、权限位等…</p>
<p>磁盘分为交换分区和数据分区，交换分区用于存放主存页面换出的动态修改数据，数据分区用于存储用户程序和数据，主存和磁盘两部分空间合并构成虚拟地址空间</p>
<p><strong>页表常驻内存</strong>，并将虚拟地址中的虚拟页号作为索引来访问。每个虚拟页对应一个页表项，</p>
<p>由于每个进程都有独立的虚拟地址空间，因此每个进程都有一张完整的页表（页表属于进程控制信息，存放在进程地址空间的内核区中）。页表在主存的首地址记录在<strong>页表基址寄存器PTB</strong>R中，进程切换时只需要切换PTBR的值就可以实现页表的快速切换。</p>
<blockquote>
<p>VA：虚拟地址<br>
PA：物理地址<br>
PTE：页表项<br>
PTEA：页表项地址</p>
</blockquote>
<p>页表项的有效位 = 1 -&gt; 当前页的数据在主存中，直接利用PPN和VPO生成物理地址，访问主存数据<br>
有效位 = 0 -&gt; 对应虚拟页可能暂未分配页；也可能对应页在磁盘中，访问页会触发缺页异常，由操作系统的缺页异常处理程序负责将磁盘的对应页载入到主存中，并更新页表项。（书中有图和例题 P.141）</p>
<p>VPN+PTBR -&gt; 页表主存中位置 – &gt; PPN  PPN + (VPO–&gt;PPO) = PA</p>
<h4 id="虚存的访问流程">虚存的访问流程</h4>
<p>书中详解 P.142</p>
<p><strong>结合cache的虚存器访问流程</strong></p>
<p>页表的部分数据块可能会作为常用的热数据调度到cache中</p>
<p>最佳情况：2次cache访问（数据和页表都在cache中命中）<br>
最坏情况：2次主存访问+磁盘访问（页表数据均未命中且缺页）</p>
<p><strong>利用TLB加速续存器地址转换</strong></p>
<p>cache缓存部分常访问的页表块的数据粒度太大，并不能充分利用虚拟存储器访问的局部性。<br>
为了进一步降低虚拟存储器地址转换的硬件开销，处理器都维护一个<strong>转换旁路缓冲区</strong>(TLB，一个较小的cache)，用于<strong>缓冲经常访问的PTE</strong>。采用全相联和组相联，随机替换算法。</p>
<p>采用组相联cache的地址划分方法，虚页号划分成TLB标记和TLB索引，便于快速判断访问的页面是否在主存中，标记字段是TLBT<br>
VPN = TLBT + TLBI  + VPO<br>
采用全相联的映射，则TLB表项中的标记字段就是VPN，</p>
<p>TLB离CPU更近，访问速度更快，将TLB称为快表，根据内容访问，主存的页表叫慢表，根据地址访问。</p>
<p>进行地址转换时，会同时查询块表和慢表</p>
<h4 id="CPU访存过程">CPU访存过程</h4>
<p>操作系统引导完成之前 — CPU只能以地址访问主存<br>
引导完成后–进入保护模式，只能用虚地址访问主存</p>
<p>书中P.145有具体图</p>
<p><strong>书后习题非常重要，注意这章的概念解释</strong></p>
<h2 id="指令系统">指令系统</h2>
<h3 id="概述-v6">概述</h3>
<p>指令：用户使用计算机与计算机本身运行的基本功能单位<br>
机器指令：计算机硬件与软件的界面，用户操作和使用计算机硬件的接口</p>
<p>一条高级语言 —&gt; 多条机器指令<br>
一条汇编语言 —&gt;(一般)一条机器指令<br>
一条机器指令 —&gt; 多条微指令</p>
<p>指令系统应该满足的条件：</p>
<ul>
<li>完备性</li>
<li>规整性：对称性+均齐性。寄存器和存储单元可以被同等对待，所有志林可以使用各种寻址方式；指令系统提供不同数据类型的支持</li>
<li>有效性</li>
<li>兼容性</li>
<li>可扩展性：指令格式的操作码预留一定的编码空间 ，方便扩展指令</li>
</ul>
<h3 id="指令格式">指令格式</h3>
<p><strong>指令字长</strong>：一条指令中的二进制位数</p>
<ul>
<li>定长指令系统：
<ul>
<li>结构简单，方便硬件实现，有利于CPU取指令、译码和指令顺序寻址</li>
<li>平均长度偏长，冗余状态多，不方便扩展</li>
</ul>
</li>
<li>变长指令系统：
<ul>
<li>结构灵活、长度可变，冗余状态少，可扩展性好</li>
<li>取指令可能涉及多次访存操作，下一条指令的地址必须在指令译码完成后才能确定，增加硬件设计难度(Intel x86)</li>
</ul>
</li>
</ul>
<p>指令可分为：半字长(CPU访问1次可读取2条)、单字长(CPU1次访问1条)、多字长。<br>
长度越大，占用主存空间大，访问时间长</p>
<h4 id="指令地址码">指令地址码</h4>
<p>指令可分为：</p>
<ol>
<li>
<p>三地址指令</p>
<p>**双目运算：**具有两个操作对象的运算。两个源操作数+一个目的操作数<br>
$$A_3 \leftarrow (A_1)OP(A_2)$$</p>
<p>3地址码很少用存储单元的地址码，一般3个操作数都是寄存器</p>
</li>
<li>
<p>双地址指令</p>
<p>$$ A_1 \leftarrow (A_1)OP(A_2)$$</p>
<p>可分为：</p>
<ul>
<li>RR(寄存器-寄存器)型</li>
<li>RS(寄存器-存储器)型</li>
<li>SS(存储器-存储器)型</li>
</ul>
</li>
<li>
<p>单地址指令</p>
<ol>
<li>
<p>单目运算类指令<br>
$$ A_1 \leftarrow OP(A_1)$$</p>
</li>
<li>
<p>隐含操作数是双目运算类指令</p>
<p>$$ A_1 \leftarrow (AC)OP(A_1)$$</p>
<p>一个操作数隐含于CPU的某个寄存器</p>
</li>
</ol>
</li>
<li>
<p>零地址指令</p>
<p>只有操作码字段没有地址字段。类似单地址指令，也有两种方式</p>
<ol>
<li>wait ret halt nop不需要任何操作数</li>
<li>隐含操作数指令</li>
</ol>
</li>
</ol>
<h4 id="指令操作码">指令操作码</h4>
<ol>
<li>
<p>定长操作码，定长优点同上。</p>
</li>
<li>
<p>变长操作码，优点同上。</p>
<p>可采用扩展操作码技术来实现变长曹组好吗，操作码的长度随地址码数目减少而增加。书中有图题P.157</p>
</li>
</ol>
<h3 id="寻址方式">寻址方式</h3>
<p>指令存放在主存中</p>
<p><strong>指令数寻址方式</strong></p>
<ol>
<li>
<p>顺序寻址</p>
<p>指令在主存中 往往按序排放</p>
</li>
<li>
<p>跳跃寻址</p>
<p>程序出现分支或转移时，要改变执行顺序。即下一条的指令不一定能通过PC+1来取到</p>
<p>例如：无条件跳转指令和条件跳转至零</p>
</li>
</ol>
<p><strong>操作数寻址方式</strong></p>
<p>操作数来源：</p>
<ol>
<li>直接来自指令地址字段？</li>
<li>存放在寄存器中</li>
<li>存放在存储器中</li>
</ol>
<p>将地址码字段细分为寻址方式字段I 和地址字段D , 例如单地址指令可划分为</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211027093000063.png" srcset="/img/loading.gif" lazyload alt="image-20211027093000063"></p>
<ol>
<li>
<p>立即寻址</p>
<p>I表示立即寻址的编码，D字段是操作数本身。操作数和指令同进退，取指令时操作数随着指令一起被送到CPU的指令寄存器中，执行指令时直接从执行寄存器获取操作数</p>
<p>取操作数快，但形式地址字段D位宽有限，操作数能表示的范围有限，一般用于变量赋初值</p>
<p>MOV EAX, 2008H</p>
</li>
<li>
<p>直接寻址</p>
<p>操作数在主存中，操作数地址由D直接给出</p>
<p>直观，不需要计算就可直接从指令中获得操作数有效地址</p>
<p>但寻址范围受限于指令中直接地址的二进制位数，数据地址存在指令中、程序和数据在内存中的存放位置受到限制</p>
<p>MOV EAX , [2008H]</p>
</li>
<li>
<p>寄存器寻址</p>
<p>D表示寄存器的编号</p>
<p>MOV EAX,ECX</p>
</li>
<li>
<p>间接寻址</p>
<p>D给出的是操作数的间接地址。地址指向的主存单元中的内容才是操作数的有效地址</p>
<p>MOV EAX , @2008H;</p>
<ul>
<li>解决了直接寻址方式寻址范围受限的问题，能用较短的地址码访问较大的主存空间</li>
<li>灵活，操作数地址改变不需要改变指令中的形式地址，只需要改变其指向的主存单元内容即可</li>
</ul>
<p>但取操作数时需要两次访问主存，降低了指令的执行速度</p>
</li>
<li>
<p>寄存器间接寻址</p>
<p>操作数地址存放在寄存器中，实际操作数在主存中（寄存器指向主存的地址）<br>
只需要一次访问主存，还可以扩充寻址范围<br>
MOV AL,[EBX]</p>
</li>
<li>
<p>相对寻址</p>
<p>把PC的内容(下一条指令地址)加上指令的形式地址D,形成操作数的有效地址</p>
<p>数据有效地址 EA = PC + D ，取指令时PC的值会修改，而计算操作数的有效地址在指令译码分析或执行阶段完成，所以有EA = PC + 1 + D？？？</p>
<ul>
<li>只需要确定程序内部操作数与指令之间的相对距离，无需知道操作数在主存的绝对地址</li>
<li>分支转移类指令，实现相对跳转转移，有利于程序在主存中灵活定位</li>
</ul>
</li>
<li>
<p>变址寻址</p>
<p>指定一个寄存器用来存放变化的地址 ，叫变址寄存器。形式字段D增加变址寄存器字段X 。X +D 就为操作数的有效地址<br>
变址寄存器提供修改量，指令提供基准量（指令执行过中，X寄存器内容可变，D内容不可变）</p>
<p>用于对线性表类的数组元素进行重复访问</p>
<p>面向用户，解决程序循环问题</p>
<p>MOV EAX ， 32[ESI]</p>
</li>
<li>
<p>基址寻址</p>
<p>指定一个寄存器来存放基地址，成为基址寄存器B.指令D存放变化的地址值。程序执行过程中B不可改变，D可改变</p>
<p>CPU内有专门的基址寄存器(EBX EBP)。若基址是EBX,则操作数在数据段，是EBP，则操作数在堆栈段</p>
<ul>
<li>面向系统，用于程序的重定位（每个用户程序不冲突（编程环境和实际环境））</li>
<li>扩展寻址空间（基址寄存器位数大）</li>
</ul>
<p><strong>偏移寻址</strong>：相对寻址、变址寻址、基址寻址（以某寄存器的内容与指令中的形式地址字段之和作为有效地址）</p>
</li>
<li>
<p>堆栈寻址</p>
<ol>
<li>
<p>存储器堆栈</p>
<p><strong>在内存空间中开辟堆栈区</strong></p>
<p>计算机普遍采用，设置堆栈指针寄存器SP指向栈顶单元，</p>
</li>
<li>
<p>寄存器堆栈</p>
<p><strong>将寄存器作为堆栈</strong></p>
<ul>
<li>寄存器堆栈栈顶规定，存储器堆栈栈顶随着栈操作而移动</li>
<li>进行堆栈操作，寄存器堆栈数据移动，存储器堆栈数据不移动（堆栈是固定的，数据是活的）</li>
<li>寄存器堆栈速度块，容量有限</li>
<li>寄存器堆栈必须采用专用堆栈指令进行控制</li>
</ul>
</li>
</ol>
</li>
<li>
<p>其他寻址</p>
<ol>
<li>变址+间接寻址</li>
<li>间接+变址寻址</li>
<li>相对+间接寻址</li>
</ol>
</li>
</ol>
<h3 id="指令类型">指令类型</h3>
<ol>
<li>算数逻辑运算指令</li>
<li>移位操作指令</li>
<li>数据传送指令</li>
<li>堆栈操作指令</li>
<li>字符串处理指令</li>
<li>程序控制指令
<ol>
<li>转移指令 （有无条件）</li>
<li>循环控制指令</li>
<li>子程序调用与返回指令</li>
</ol>
</li>
<li>输入输出指令</li>
<li>其他</li>
</ol>
<h3 id="指令格式设计">指令格式设计</h3>
<h3 id="CISC-RISC">CISC RISC</h3>
<p>CISC：复杂指令集计算机<br>
RISC：精简指令集计算机（80 -20 ）</p>
<p>目的和特点 看书 P.168</p>
<p><strong>不同操作系统中的指令格式</strong>，书中有</p>
<h2 id="中央处理器">中央处理器</h2>
<p>CPU上电复位后周而复始地取指令、执行指令工作。<br>
具备功能：</p>
<ol>
<li>程序控制</li>
<li>操作控制。产生指令执行过程中需要的操作控制信号，以控制执行部件按指令规定的操作正常运行（执行加法指令运算，CPU必须生成运算器的运算选择控制信号）</li>
<li>时序控制。严格控制每个操作控制信号的开始时间和持续时间</li>
<li>数据加工。对数据进行算数、逻辑运算</li>
<li>中断处理。响应内部异常和外部中断请求(运算异常、缺页、外部设备中断)</li>
</ol>
<h3 id="组成-v2">组成</h3>
<p><strong>主要寄存器</strong></p>
<ol>
<li>
<p>程序计数器 PC：</p>
<p>保存<strong>将要执行的指令的字节地址</strong>，Intelx86叫指令指针寄存器IP.</p>
<p><strong>PC位宽与主存地址总线位宽相同</strong></p>
<p>CPU取指令，利用PC的内容作为地址访问主存，并将主存取出的指令字送入指令寄存器中，病修改PC的值以形成下一条指令的地址。</p>
</li>
<li>
<p>(存储器)地址寄存器 AR：</p>
<p>保存CPU访问主存的单元地址，无论CPU是取操作还是存数据，都要将访问地址送入AR中。<br>
<strong>位宽和主存地址总线位宽相同</strong>，AR并非必须，可将访存地址加载到地址总线上实现</p>
</li>
<li>
<p>(存储器)数据寄存器 DR：</p>
<p>存放从主存中读出的数据或者准备写入主存的数据（cache？）</p>
<p><strong>数据位宽与机器字长相同</strong>，并非必须</p>
</li>
<li>
<p>指令寄存器 IR：</p>
<p><strong>保存当前正在执行的指令</strong>（而非地址）</p>
<p>位宽和指令字相同，指令字由指令译码器ID翻译成若干个指令译码信号（每个信号表示一条不同指令，同一时刻只有一个信号有效）<br>
指令字中的地址码部分由地址生成逻辑对寻址方式进行译码并生成目标地址或数据，根据寻址方式的不同将目标地址送入程序计数器PC、AR和运算部件中 （？？？）</p>
<p>并非必须</p>
</li>
<li>
<p>通用寄存器组 GR</p>
<p>运算器内部的若干寄存器 — 寄存器堆。</p>
</li>
<li>
<p>程序状态字寄出去你 PSW/PSR</p>
<p>保存由算数运算指令、逻辑运算指令、测试指令等建立的各种条件标志。(进位标志、溢出标志、结果为负数、零标志)。还可保存中断和系统工作的状态信息，方便CPU及时了解计算机运行状态</p>
</li>
</ol>
<p><strong>操作控制器</strong></p>
<p>接受指令译码器ID送来的指令译码信息，与时序信号、条件以及状态信息进行组合，形成各种具有严格时间先后顺序的操作控制信号（微操作控制信号序列  — 控制流），连接到计算机各功能部件的控制端。</p>
<p>按照时间先后打开或关闭某些特定的线路</p>
<p><strong>时序产生器</strong></p>
<p>对完成指令而执行的微操作控制信号进行时间调制，严格规定各信号的产生时间和持续时间</p>
<p>根据时序调制方法不同，操作控制器分为：</p>
<ul>
<li>硬布线控制器。采用时序逻辑实现，按照同步时序电路设计方法设计，硬时序</li>
<li>微程序控制器。采用程序存储逻辑实现，软时序</li>
</ul>
<h3 id="指令周期">指令周期</h3>
<p>指令周期：将一条指令从取出到执行完成所需要的时间</p>
<p>阶段：</p>
<ol>
<li>
<p>取指周期</p>
<p>CPU以PC的内容位地址从主存中取出指令，并计算后续指令的地址<br>
（对于变长指令，需要经过指令译码得到实际字节长度后才能计算并修改PC的值）</p>
</li>
<li>
<p>译码、取操作数周期</p>
<p>对指令寄存器的指令字进行指令译码，识别指令类型。（部分实现将译码阶段划分到取指周期中）</p>
<p>根据指令地址码生成的操作数有效地址（由寻址方式决定），访问相应的寄存器和主存单元。</p>
<p>对于间接寻址，还需要加入访存周期（间址地址）才能得到操作数的地址</p>
</li>
<li>
<p>执行周期</p>
<p>控制器向ALU及数据通路中的其他相关部件发送操作控制指令，对已经取出的操作数进行加工处理，并将处理的状态信息记录到PSW中</p>
</li>
<li>
<p>写回周期</p>
<p>将运算结果写回到目的寄存器或存储器中，可能需要多个时钟周期</p>
</li>
</ol>
<p>还可能有中断周期、总线周期、IO周期等</p>
<p>便于同步，将<strong>指令周期划分成若干个机器周期</strong>（CPU周期）<br>
<strong>机器周期</strong>：从主存中取出一个存储字所需要的最短时间<br>
<strong>时钟周期</strong>：也称为振荡周期，定义为时钟脉冲的倒数，<strong>是计算机中最基本的、最小的时间单位</strong>。</p>
<p>每个机器周期又包含若干个时钟周期</p>
<p>指令周期的机器周期数和每个机器周期包含的时钟周期数不一定固定</p>
<p><strong>寄存器传送语言 RTL</strong></p>
<p>每条指令的执行过程都可分解为一组操作序列，进而分解为一组微操作序列。<br>
<strong>操作</strong>：功能部件级的动作<br>
<strong>微操作</strong>：指令序列中最基本、不可再分的动作</p>
<h1>一些问题</h1>
<h3 id="CPU多少位指什么？地址总线、数据总线能带来哪些影响"><strong>CPU多少位指什么？地址总线、数据总线能带来哪些影响</strong></h3>
<p>多少位CPU代表的是一次能够从处理多少位的数据，地址总线 ！= 位数</p>
<ul>
<li>地址总线：CPU的寻址能力，决定了可直接寻址的内存空间大小</li>
<li>控制总线：传送控制信号和时序信号（读写信号、片选信号、中断响应信号）</li>
<li>数据总线：数据传送能力。CPU-&gt;内存/IO 内存/IO -&gt;CPU均可，双向三态形</li>
</ul>
<h3 id="64位和32位CPU的实质区别？"><strong>64位和32位CPU的实质区别？</strong></h3>
<p>64 位 CPU 是指 CPU 内部的<strong>通用寄存器</strong>的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算</p>
<ul>
<li>数据处理能力增强：64 位 CPU 通用寄存器的位宽增加一倍，这也就意味着 64 位 CPU 可以一次性处理 64bit 的整形数据；</li>
<li>内存寻址能力增强：如果是 32 位 CPU 的话，它的地址总线最多不会超过 32，那么它所能达到的寻址范围也就不会超过 2 的 32 次方字节（存储单元以字节为单位），也就是 4GB，而如果是 64 位处理器的话，它所能达到的寻址范围<strong>理论上</strong>就会是 2 的 64 次方字节（上亿 GB）。</li>
</ul>
<div class="note note-success">
            <p>一般处理器多少位是指通用寄存器的长度，当然数据线需要与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。</p>
          </div>
<p>注意了，64位操作系统只能运行在64位CPU上</p>
<p><strong>64位CPU装了32位操作系统后寻址能力为什么是4GB</strong></p>
<p>32位操作系统没有对应的64位的寻址指令，不能提供4GB以上的逻辑地址</p>
<h3 id="GPU和CPU的区别"><strong>GPU和CPU的区别</strong></h3>
<p>CPU需要很强的<strong>通用性</strong>来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。</p>
<p>而GPU面对的则是<strong>类型高度统一的</strong>、<strong>相互无依赖</strong>的大规模数据和不需要被打断的<strong>纯净的计算环境</strong>。</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211026212402274.png" srcset="/img/loading.gif" lazyload alt="image-20211026212402274"></p>
<p>GPU采用了数量众多的计算单元和超长的流水线，但只有非常简单的控制逻辑并省去了Cache。<br>
CPU不仅被Cache占据了大量空间，而且还有有复杂的控制逻辑和诸多优化电路，相比之下计算能力只是CPU很小的一部分</p>
<p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20211026212600405.png" srcset="/img/loading.gif" lazyload alt="image-20211026212600405"></p>
<p>**Cache, local memory： CPU &gt; GPU **<br>
<strong>Threads(线程数): GPU &gt; CPU</strong><br>
Registers: GPU &gt; CPU  多寄存器可以支持非常多的Thread,thread需要用到register,thread数目大，register也必须得跟着很大才行。<br>
SIMD Unit(单指令多数据流,以同步方式，在同一时间内执行同一条指令): GPU &gt; CPU。</p>
<ul>
<li>CPU时延低：有强大的ALU（算术运算单元）,它可以在很少的时钟周期内完成算术计算。时钟周期的频率非常高。复杂的逻辑控制单元可以确保当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。</li>
<li>GPU基于大的吞吐量设计：GPU的特点是有<strong>很多的ALU</strong>和很少的cache. 缓存的目的不是保存后面需要访问的数据的，这点和CPU不同，而是为thread提高服务的。如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问dram（因为需要访问的数据保存在dram中而不是cache里面），获取数据后cache会转发这个数据给对应的线程，这个时候是数据转发的角色。但是由于需要访问dram，自然会带来延时的问题。</li>
</ul>
<p>CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长的是大规模并发计算</p>
<p>GPU大部分工作计算量大，没啥技术含量，重复很多次。并行计算（流水线，无法单独工作，必须由cpu控制）</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19903344">知乎</a></p>

                                    </div>
                                    <hr>
                                    <div>
                                        <div class="post-metas mb-3">
                                            
                                                    
                                                        <div class="post-meta">
                                                            <i class="iconfont icon-tags"></i>
                                                            
                                                                <a class="hover-with-bg" href="/tags/%E8%80%83%E7%A0%94/">
                                                                    考研
                                                                </a>
                                                                
                                                                <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/">
                                                                    计算机原理
                                                                </a>
                                                                
                                                        </div>
                                                        
                                        </div>
                                        
                                            <p class="note note-warning">
                                                
                                                            本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                                                                
                                            </p>
                                            
                                                
                                                    <div class="post-prevnext">
                                                        <article class="post-prev col-6">
                                                            
                                                                
                                                                    <a href="/2021/10/25/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/">
                                                                        <i class="iconfont icon-arrowleft"></i>
                                                                        <span class="hidden-mobile">Linux内核学习</span>
                                                                        <span class="visible-mobile">上一篇</span>
                                                                    </a>
                                                                    
                                                        </article>
                                                        <article class="post-next col-6">
                                                            
                                                                
                                                                    <a href="/2021/10/16/%E4%B8%80%E4%BA%9B%E7%82%B9%E5%AD%90/">
                                                                        <span class="hidden-mobile">一些点子</span>
                                                                        <span class="visible-mobile">下一篇</span>
                                                                        <i class="iconfont icon-arrowright"></i>
                                                                    </a>
                                                                    
                                                        </article>
                                                    </div>
                                                    
                                    </div>

                                    
                                        <!-- Comments -->
                                        <article class="comments" id="comments" lazyload>
                                            
                                                        
                                                            
                                                                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'dark-blue';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'PPLong222/commit-utterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


                                        </article>
                                        
                        </article>
                    </div>
                </div>
            </div>
            
                <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
                    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

                </div>
                
        </div>
    </div>

    <!-- Custom -->
    
    <!--添加我自己的设置页面-->
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
    <!--加入自定义格式的-->
    <!--自定义的git徽标样式-->
<img height="20" src="https://img.shields.io/badge/Source-Github-blue?logo=github&style=flat&logoColor=rgb(252,%2098,%2093)&color=blue" srcset="/img/loading.gif" lazyload>
<img height="20" src="https://img.shields.io/badge/Build-Hexo-blue?logo=hexo&style=flat&logoColor=rgb(14,%20131,%20205)&color=fc766a" srcset="/img/loading.gif" lazyload>
<img height="20" src="https://img.shields.io/badge/Build-Fluid-blue?logo=hexo&style=flat&logoColor=rgb(14,%20131,%20205)&color=f2c080" srcset="/img/loading.gif" lazyload>
<br>
<img height="20" src="https://img.shields.io/badge/蜀ICP备-2022003192号-blue?logo=data:image/png;base64,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&style=flat&color=d2c68b" srcset="/img/loading.gif" lazyload>

<!-- 自定义显示文章总页数和字数的模块 -->
<div class="bottom-post-statistic">
    <div class="bottom-post-count">
        62&nbsp 篇文章
    </div>
    <div class="bottom-post-word">
        296.2k&nbsp 字
    </div>
</div>
        <div class="footer-content">
             <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
        </div>

        
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


            

                
</footer>

  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  
    
  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  




  
<script src="/js/reset_code_lang.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <!-- 暂时先不引入该功能 -->
  <!-- 引入JQuery -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> -->
  <!-- 引入自定义的页面访问和ip统计脚本 -->
  <!-- <script src="/js/send_req_info.js"></script> --> -->
<!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?PPLong222";
            var git_color =['#ebedf0', '#bef5cb', '#bef5cb', '#a9f5b4', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'];
            var git_user ="PPLong222";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div id="github-calendar" style="width:100%;height:auto;padding:10px;margin-bottom:20px"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;margin-top:100px;;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:200px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>#github_container > .position-relative > .border{border:0!important}#github-calendar{position: relative;margin-top: -2rem;background-color: var(--board-bg-color);transition: background-color 0.2s ease-in-out;border-radius: 0.5rem;z-index: 3;-webkit-box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);box-shadow: 0 12px 15px 0 rgb(0 0 0 / 24%), 0 17px 50px 0 rgb(0 0 0 / 19%);}</style><!-- hexo injector body_end end --></body>
</html>
